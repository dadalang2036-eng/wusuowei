<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>给萝卜的圣诞树 - 最终浪漫版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <style>
        body { margin: 0; background: radial-gradient(circle at center, #001525 0%, #000 100%); overflow: hidden; }
        .ui-overlay { font-family: 'Inter', sans-serif; }
        canvas { filter: drop-shadow(0 0 10px rgba(34, 197, 94, 0.2)); }
    </style>
</head>
<body>
    <div class="ui-overlay absolute inset-0 z-10 pointer-events-none flex flex-col justify-between p-12">
        <div class="space-y-2">
            <h1 class="text-white text-6xl font-thin tracking-tighter uppercase opacity-80">Merry <span class="font-black text-green-400">Xmas</span></h1>
            <div class="h-1 w-32 bg-gradient-to-r from-green-500 to-transparent"></div>
            <p class="text-green-200/50 font-mono text-xs tracking-[0.5em]">DESTINATION: LUOBO_STATION</p>
        </div>
        
        <div class="flex justify-between items-end border-t border-white/10 pt-4">
            <div class="text-[10px] font-mono text-green-500/80 leading-relaxed">
                [ SYSTEM_LOG ]<br>
                > BIOMASS_COLOR_MAPPING: ENABLED<br>
                > SNOW_PHYSICS: ACTIVE
            </div>
            <div class="text-white/40 text-xs">© 2025 CREATIVE TECHNOLOGIST</div>
        </div>
    </div>

    <script>
        window.onload = () => {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 35);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // --- 1. 动态雪花系统 ---
            const snowCount = 2500;
            const snowGeo = new THREE.BufferGeometry();
            const snowPos = new Float32Array(snowCount * 3);
            for(let i=0; i<snowCount*3; i++) snowPos[i] = (Math.random() - 0.5) * 100;
            snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
            const snowMat = new THREE.PointsMaterial({ size: 0.15, color: 0xffffff, transparent: true, opacity: 0.6 });
            const snow = new THREE.Points(snowGeo, snowMat);
            scene.add(snow);

            // --- 2. 核心树体（棕色树干+绿色树冠） ---
            const createTree = () => {
                const count = 40000; // 极高密度
                const pos = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const color = new THREE.Color();

                for (let i = 0; i < count; i++) {
                    const ratio = i / count;
                    const y = ratio * 22 - 8;
                    let x, z, r;

                    // 判别逻辑：轴心窄半径为树干
                    const isTrunk = (Math.random() > 0.3 && ratio < 0.25) || (Math.pow(Math.random(), 2) < 0.05 && ratio < 0.6);
                    
                    if (isTrunk) {
                        r = Math.random() * 0.8;
                        const angle = Math.random() * Math.PI * 2;
                        x = Math.cos(angle) * r;
                        z = Math.sin(angle) * r;
                        // 棕色：暗褐色到木质色
                        color.setHSL(0.05, 0.4, 0.05 + Math.random() * 0.1);
                    } else {
                        // 树冠：带波浪的分层算法
                        const wave = Math.sin(ratio * 40) * 0.3;
                        const maxR = (1 - ratio) * 9 + wave;
                        const angle = i * 0.3;
                        const dist = Math.sqrt(Math.random()) * maxR;
                        x = Math.cos(angle) * dist;
                        z = Math.sin(angle) * dist;
                        // 绿色：深林绿到明亮青翠
                        color.setHSL(0.35, 0.7, 0.1 + ratio * 0.4);
                    }

                    pos[i * 3] = x;
                    pos[i * 3 + 1] = y;
                    pos[i * 3 + 2] = z;
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }

                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                const mat = new THREE.PointsMaterial({
                    size: 0.08, 
                    vertexColors: true, 
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.9
                });
                return new THREE.Points(geo, mat);
            };

            const tree = createTree();
            scene.add(tree);

            // --- 3. 树顶辉光核心 ---
            const star = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 24, 24),
                new THREE.MeshBasicMaterial({ color: 0xffffaa })
            );
            star.position.y = 14.5;
            scene.add(star);

            // --- 4. 动画逻辑 ---
            const clock = new THREE.Clock();
            function animate() {
                const delta = clock.getDelta();
                const elapsed = clock.getElapsedTime();
                requestAnimationFrame(animate);
                
                // 树体缓慢自转
                tree.rotation.y += 0.005;
                
                // 雪花物理：匀速下落 + 摆动
                const snowPositions = snow.geometry.attributes.position.array;
                for(let i = 0; i < snowPositions.length; i += 3) {
                    snowPositions[i + 1] -= 0.05; // 下落速度
                    snowPositions[i] += Math.sin(elapsed + i) * 0.01; // 横向摆动
                    if(snowPositions[i+1] < -20) snowPositions[i+1] = 30; // 循环
                }
                snow.geometry.attributes.position.needsUpdate = true;

                // 树顶星呼吸
                star.scale.setScalar(1 + Math.sin(elapsed * 3) * 0.2);
                
                renderer.render(scene, camera);
            }
            animate();

            // 窗口自适应
            window.onresize = () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            };
        };
    </script>
</body>
</html>